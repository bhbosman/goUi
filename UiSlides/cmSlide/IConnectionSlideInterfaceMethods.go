// Code generated by MockGen. DO NOT EDIT.
// Source: github.com/bhbosman/goUi/UiSlides/cmSlide (interfaces: IConnectionSlide)

// Package cmSlide is a generated GoMock package.
package cmSlide

import (
	"context"
	fmt "fmt"

	errors "github.com/bhbosman/gocommon/errors"
)

// Interface A Comment
// Interface github.com/bhbosman/goUi/UiSlides/cmSlide
// Interface IConnectionSlide
// Interface IConnectionSlide, Method: DisconnectAllConnections
type IConnectionSlideDisconnectAllConnectionsIn struct {
}

type IConnectionSlideDisconnectAllConnectionsOut struct {
}
type IConnectionSlideDisconnectAllConnectionsError struct {
	InterfaceName string
	MethodName    string
	Reason        string
}

func (self *IConnectionSlideDisconnectAllConnectionsError) Error() string {
	return fmt.Sprintf("error in data coming back from %v::%v. Reason: %v", self.InterfaceName, self.MethodName, self.Reason)
}

type IConnectionSlideDisconnectAllConnections struct {
	inData         IConnectionSlideDisconnectAllConnectionsIn
	outDataChannel chan IConnectionSlideDisconnectAllConnectionsOut
}

func NewIConnectionSlideDisconnectAllConnections(waitToComplete bool) *IConnectionSlideDisconnectAllConnections {
	var outDataChannel chan IConnectionSlideDisconnectAllConnectionsOut
	if waitToComplete {
		outDataChannel = make(chan IConnectionSlideDisconnectAllConnectionsOut)
	} else {
		outDataChannel = nil
	}
	return &IConnectionSlideDisconnectAllConnections{
		inData:         IConnectionSlideDisconnectAllConnectionsIn{},
		outDataChannel: outDataChannel,
	}
}

func (self *IConnectionSlideDisconnectAllConnections) Wait(onError func(interfaceName string, methodName string, err error) error) (IConnectionSlideDisconnectAllConnectionsOut, error) {
	data, ok := <-self.outDataChannel
	if !ok {
		generatedError := &IConnectionSlideDisconnectAllConnectionsError{
			InterfaceName: "IConnectionSlide",
			MethodName:    "DisconnectAllConnections",
			Reason:        "Channel for IConnectionSlide::DisconnectAllConnections returned false",
		}
		if onError != nil {
			err := onError("IConnectionSlide", "DisconnectAllConnections", generatedError)
			return IConnectionSlideDisconnectAllConnectionsOut{}, err
		} else {
			return IConnectionSlideDisconnectAllConnectionsOut{}, generatedError
		}
	}
	return data, nil
}

func (self *IConnectionSlideDisconnectAllConnections) Close() error {
	close(self.outDataChannel)
	return nil
}
func CallIConnectionSlideDisconnectAllConnections(context context.Context, channel chan<- interface{}, waitToComplete bool) (IConnectionSlideDisconnectAllConnectionsOut, error) {
	if context != nil && context.Err() != nil {
		return IConnectionSlideDisconnectAllConnectionsOut{}, context.Err()
	}
	data := NewIConnectionSlideDisconnectAllConnections(waitToComplete)
	if waitToComplete {
		defer func(data *IConnectionSlideDisconnectAllConnections) {
			err := data.Close()
			if err != nil {
			}
		}(data)
	}
	if context != nil && context.Err() != nil {
		return IConnectionSlideDisconnectAllConnectionsOut{}, context.Err()
	}
	channel <- data
	var err error
	var v IConnectionSlideDisconnectAllConnectionsOut
	if waitToComplete {
		v, err = data.Wait(func(interfaceName string, methodName string, err error) error {
			return err
		})
	} else {
		err = errors.NoWaitOperationError
	}
	if err != nil {
		return IConnectionSlideDisconnectAllConnectionsOut{}, err
	}
	return v, nil
}

// Interface IConnectionSlide, Method: DisconnectConnection
type IConnectionSlideDisconnectConnectionIn struct {
	arg0 string
}

type IConnectionSlideDisconnectConnectionOut struct {
}
type IConnectionSlideDisconnectConnectionError struct {
	InterfaceName string
	MethodName    string
	Reason        string
}

func (self *IConnectionSlideDisconnectConnectionError) Error() string {
	return fmt.Sprintf("error in data coming back from %v::%v. Reason: %v", self.InterfaceName, self.MethodName, self.Reason)
}

type IConnectionSlideDisconnectConnection struct {
	inData         IConnectionSlideDisconnectConnectionIn
	outDataChannel chan IConnectionSlideDisconnectConnectionOut
}

func NewIConnectionSlideDisconnectConnection(waitToComplete bool, arg0 string) *IConnectionSlideDisconnectConnection {
	var outDataChannel chan IConnectionSlideDisconnectConnectionOut
	if waitToComplete {
		outDataChannel = make(chan IConnectionSlideDisconnectConnectionOut)
	} else {
		outDataChannel = nil
	}
	return &IConnectionSlideDisconnectConnection{
		inData: IConnectionSlideDisconnectConnectionIn{
			arg0: arg0,
		},
		outDataChannel: outDataChannel,
	}
}

func (self *IConnectionSlideDisconnectConnection) Wait(onError func(interfaceName string, methodName string, err error) error) (IConnectionSlideDisconnectConnectionOut, error) {
	data, ok := <-self.outDataChannel
	if !ok {
		generatedError := &IConnectionSlideDisconnectConnectionError{
			InterfaceName: "IConnectionSlide",
			MethodName:    "DisconnectConnection",
			Reason:        "Channel for IConnectionSlide::DisconnectConnection returned false",
		}
		if onError != nil {
			err := onError("IConnectionSlide", "DisconnectConnection", generatedError)
			return IConnectionSlideDisconnectConnectionOut{}, err
		} else {
			return IConnectionSlideDisconnectConnectionOut{}, generatedError
		}
	}
	return data, nil
}

func (self *IConnectionSlideDisconnectConnection) Close() error {
	close(self.outDataChannel)
	return nil
}
func CallIConnectionSlideDisconnectConnection(context context.Context, channel chan<- interface{}, waitToComplete bool, arg0 string) (IConnectionSlideDisconnectConnectionOut, error) {
	if context != nil && context.Err() != nil {
		return IConnectionSlideDisconnectConnectionOut{}, context.Err()
	}
	data := NewIConnectionSlideDisconnectConnection(waitToComplete, arg0)
	if waitToComplete {
		defer func(data *IConnectionSlideDisconnectConnection) {
			err := data.Close()
			if err != nil {
			}
		}(data)
	}
	if context != nil && context.Err() != nil {
		return IConnectionSlideDisconnectConnectionOut{}, context.Err()
	}
	channel <- data
	var err error
	var v IConnectionSlideDisconnectConnectionOut
	if waitToComplete {
		v, err = data.Wait(func(interfaceName string, methodName string, err error) error {
			return err
		})
	} else {
		err = errors.NoWaitOperationError
	}
	if err != nil {
		return IConnectionSlideDisconnectConnectionOut{}, err
	}
	return v, nil
}

// Interface IConnectionSlide, Method: ResetAllConnectionParams
type IConnectionSlideResetAllConnectionParamsIn struct {
}

type IConnectionSlideResetAllConnectionParamsOut struct {
}
type IConnectionSlideResetAllConnectionParamsError struct {
	InterfaceName string
	MethodName    string
	Reason        string
}

func (self *IConnectionSlideResetAllConnectionParamsError) Error() string {
	return fmt.Sprintf("error in data coming back from %v::%v. Reason: %v", self.InterfaceName, self.MethodName, self.Reason)
}

type IConnectionSlideResetAllConnectionParams struct {
	inData         IConnectionSlideResetAllConnectionParamsIn
	outDataChannel chan IConnectionSlideResetAllConnectionParamsOut
}

func NewIConnectionSlideResetAllConnectionParams(waitToComplete bool) *IConnectionSlideResetAllConnectionParams {
	var outDataChannel chan IConnectionSlideResetAllConnectionParamsOut
	if waitToComplete {
		outDataChannel = make(chan IConnectionSlideResetAllConnectionParamsOut)
	} else {
		outDataChannel = nil
	}
	return &IConnectionSlideResetAllConnectionParams{
		inData:         IConnectionSlideResetAllConnectionParamsIn{},
		outDataChannel: outDataChannel,
	}
}

func (self *IConnectionSlideResetAllConnectionParams) Wait(onError func(interfaceName string, methodName string, err error) error) (IConnectionSlideResetAllConnectionParamsOut, error) {
	data, ok := <-self.outDataChannel
	if !ok {
		generatedError := &IConnectionSlideResetAllConnectionParamsError{
			InterfaceName: "IConnectionSlide",
			MethodName:    "ResetAllConnectionParams",
			Reason:        "Channel for IConnectionSlide::ResetAllConnectionParams returned false",
		}
		if onError != nil {
			err := onError("IConnectionSlide", "ResetAllConnectionParams", generatedError)
			return IConnectionSlideResetAllConnectionParamsOut{}, err
		} else {
			return IConnectionSlideResetAllConnectionParamsOut{}, generatedError
		}
	}
	return data, nil
}

func (self *IConnectionSlideResetAllConnectionParams) Close() error {
	close(self.outDataChannel)
	return nil
}
func CallIConnectionSlideResetAllConnectionParams(context context.Context, channel chan<- interface{}, waitToComplete bool) (IConnectionSlideResetAllConnectionParamsOut, error) {
	if context != nil && context.Err() != nil {
		return IConnectionSlideResetAllConnectionParamsOut{}, context.Err()
	}
	data := NewIConnectionSlideResetAllConnectionParams(waitToComplete)
	if waitToComplete {
		defer func(data *IConnectionSlideResetAllConnectionParams) {
			err := data.Close()
			if err != nil {
			}
		}(data)
	}
	if context != nil && context.Err() != nil {
		return IConnectionSlideResetAllConnectionParamsOut{}, context.Err()
	}
	channel <- data
	var err error
	var v IConnectionSlideResetAllConnectionParamsOut
	if waitToComplete {
		v, err = data.Wait(func(interfaceName string, methodName string, err error) error {
			return err
		})
	} else {
		err = errors.NoWaitOperationError
	}
	if err != nil {
		return IConnectionSlideResetAllConnectionParamsOut{}, err
	}
	return v, nil
}

// Interface IConnectionSlide, Method: ResetConnectionParams
type IConnectionSlideResetConnectionParamsIn struct {
	arg0 string
}

type IConnectionSlideResetConnectionParamsOut struct {
}
type IConnectionSlideResetConnectionParamsError struct {
	InterfaceName string
	MethodName    string
	Reason        string
}

func (self *IConnectionSlideResetConnectionParamsError) Error() string {
	return fmt.Sprintf("error in data coming back from %v::%v. Reason: %v", self.InterfaceName, self.MethodName, self.Reason)
}

type IConnectionSlideResetConnectionParams struct {
	inData         IConnectionSlideResetConnectionParamsIn
	outDataChannel chan IConnectionSlideResetConnectionParamsOut
}

func NewIConnectionSlideResetConnectionParams(waitToComplete bool, arg0 string) *IConnectionSlideResetConnectionParams {
	var outDataChannel chan IConnectionSlideResetConnectionParamsOut
	if waitToComplete {
		outDataChannel = make(chan IConnectionSlideResetConnectionParamsOut)
	} else {
		outDataChannel = nil
	}
	return &IConnectionSlideResetConnectionParams{
		inData: IConnectionSlideResetConnectionParamsIn{
			arg0: arg0,
		},
		outDataChannel: outDataChannel,
	}
}

func (self *IConnectionSlideResetConnectionParams) Wait(onError func(interfaceName string, methodName string, err error) error) (IConnectionSlideResetConnectionParamsOut, error) {
	data, ok := <-self.outDataChannel
	if !ok {
		generatedError := &IConnectionSlideResetConnectionParamsError{
			InterfaceName: "IConnectionSlide",
			MethodName:    "ResetConnectionParams",
			Reason:        "Channel for IConnectionSlide::ResetConnectionParams returned false",
		}
		if onError != nil {
			err := onError("IConnectionSlide", "ResetConnectionParams", generatedError)
			return IConnectionSlideResetConnectionParamsOut{}, err
		} else {
			return IConnectionSlideResetConnectionParamsOut{}, generatedError
		}
	}
	return data, nil
}

func (self *IConnectionSlideResetConnectionParams) Close() error {
	close(self.outDataChannel)
	return nil
}
func CallIConnectionSlideResetConnectionParams(context context.Context, channel chan<- interface{}, waitToComplete bool, arg0 string) (IConnectionSlideResetConnectionParamsOut, error) {
	if context != nil && context.Err() != nil {
		return IConnectionSlideResetConnectionParamsOut{}, context.Err()
	}
	data := NewIConnectionSlideResetConnectionParams(waitToComplete, arg0)
	if waitToComplete {
		defer func(data *IConnectionSlideResetConnectionParams) {
			err := data.Close()
			if err != nil {
			}
		}(data)
	}
	if context != nil && context.Err() != nil {
		return IConnectionSlideResetConnectionParamsOut{}, context.Err()
	}
	channel <- data
	var err error
	var v IConnectionSlideResetConnectionParamsOut
	if waitToComplete {
		v, err = data.Wait(func(interfaceName string, methodName string, err error) error {
			return err
		})
	} else {
		err = errors.NoWaitOperationError
	}
	if err != nil {
		return IConnectionSlideResetConnectionParamsOut{}, err
	}
	return v, nil
}

// Interface IConnectionSlide, Method: Send
type IConnectionSlideSendIn struct {
	arg0 interface{}
}

type IConnectionSlideSendOut struct {
	Args0 error
}
type IConnectionSlideSendError struct {
	InterfaceName string
	MethodName    string
	Reason        string
}

func (self *IConnectionSlideSendError) Error() string {
	return fmt.Sprintf("error in data coming back from %v::%v. Reason: %v", self.InterfaceName, self.MethodName, self.Reason)
}

type IConnectionSlideSend struct {
	inData         IConnectionSlideSendIn
	outDataChannel chan IConnectionSlideSendOut
}

func NewIConnectionSlideSend(waitToComplete bool, arg0 interface{}) *IConnectionSlideSend {
	var outDataChannel chan IConnectionSlideSendOut
	if waitToComplete {
		outDataChannel = make(chan IConnectionSlideSendOut)
	} else {
		outDataChannel = nil
	}
	return &IConnectionSlideSend{
		inData: IConnectionSlideSendIn{
			arg0: arg0,
		},
		outDataChannel: outDataChannel,
	}
}

func (self *IConnectionSlideSend) Wait(onError func(interfaceName string, methodName string, err error) error) (IConnectionSlideSendOut, error) {
	data, ok := <-self.outDataChannel
	if !ok {
		generatedError := &IConnectionSlideSendError{
			InterfaceName: "IConnectionSlide",
			MethodName:    "Send",
			Reason:        "Channel for IConnectionSlide::Send returned false",
		}
		if onError != nil {
			err := onError("IConnectionSlide", "Send", generatedError)
			return IConnectionSlideSendOut{}, err
		} else {
			return IConnectionSlideSendOut{}, generatedError
		}
	}
	return data, nil
}

func (self *IConnectionSlideSend) Close() error {
	close(self.outDataChannel)
	return nil
}
func CallIConnectionSlideSend(context context.Context, channel chan<- interface{}, waitToComplete bool, arg0 interface{}) (IConnectionSlideSendOut, error) {
	if context != nil && context.Err() != nil {
		return IConnectionSlideSendOut{}, context.Err()
	}
	data := NewIConnectionSlideSend(waitToComplete, arg0)
	if waitToComplete {
		defer func(data *IConnectionSlideSend) {
			err := data.Close()
			if err != nil {
			}
		}(data)
	}
	if context != nil && context.Err() != nil {
		return IConnectionSlideSendOut{}, context.Err()
	}
	channel <- data
	var err error
	var v IConnectionSlideSendOut
	if waitToComplete {
		v, err = data.Wait(func(interfaceName string, methodName string, err error) error {
			return err
		})
	} else {
		err = errors.NoWaitOperationError
	}
	if err != nil {
		return IConnectionSlideSendOut{}, err
	}
	return v, nil
}

// Interface IConnectionSlide, Method: SetConnectionInstanceChange
type IConnectionSlideSetConnectionInstanceChangeIn struct {
	arg0 func(ConnectionInstanceData)
}

type IConnectionSlideSetConnectionInstanceChangeOut struct {
}
type IConnectionSlideSetConnectionInstanceChangeError struct {
	InterfaceName string
	MethodName    string
	Reason        string
}

func (self *IConnectionSlideSetConnectionInstanceChangeError) Error() string {
	return fmt.Sprintf("error in data coming back from %v::%v. Reason: %v", self.InterfaceName, self.MethodName, self.Reason)
}

type IConnectionSlideSetConnectionInstanceChange struct {
	inData         IConnectionSlideSetConnectionInstanceChangeIn
	outDataChannel chan IConnectionSlideSetConnectionInstanceChangeOut
}

func NewIConnectionSlideSetConnectionInstanceChange(waitToComplete bool, arg0 func(ConnectionInstanceData)) *IConnectionSlideSetConnectionInstanceChange {
	var outDataChannel chan IConnectionSlideSetConnectionInstanceChangeOut
	if waitToComplete {
		outDataChannel = make(chan IConnectionSlideSetConnectionInstanceChangeOut)
	} else {
		outDataChannel = nil
	}
	return &IConnectionSlideSetConnectionInstanceChange{
		inData: IConnectionSlideSetConnectionInstanceChangeIn{
			arg0: arg0,
		},
		outDataChannel: outDataChannel,
	}
}

func (self *IConnectionSlideSetConnectionInstanceChange) Wait(onError func(interfaceName string, methodName string, err error) error) (IConnectionSlideSetConnectionInstanceChangeOut, error) {
	data, ok := <-self.outDataChannel
	if !ok {
		generatedError := &IConnectionSlideSetConnectionInstanceChangeError{
			InterfaceName: "IConnectionSlide",
			MethodName:    "SetConnectionInstanceChange",
			Reason:        "Channel for IConnectionSlide::SetConnectionInstanceChange returned false",
		}
		if onError != nil {
			err := onError("IConnectionSlide", "SetConnectionInstanceChange", generatedError)
			return IConnectionSlideSetConnectionInstanceChangeOut{}, err
		} else {
			return IConnectionSlideSetConnectionInstanceChangeOut{}, generatedError
		}
	}
	return data, nil
}

func (self *IConnectionSlideSetConnectionInstanceChange) Close() error {
	close(self.outDataChannel)
	return nil
}
func CallIConnectionSlideSetConnectionInstanceChange(context context.Context, channel chan<- interface{}, waitToComplete bool, arg0 func(ConnectionInstanceData)) (IConnectionSlideSetConnectionInstanceChangeOut, error) {
	if context != nil && context.Err() != nil {
		return IConnectionSlideSetConnectionInstanceChangeOut{}, context.Err()
	}
	data := NewIConnectionSlideSetConnectionInstanceChange(waitToComplete, arg0)
	if waitToComplete {
		defer func(data *IConnectionSlideSetConnectionInstanceChange) {
			err := data.Close()
			if err != nil {
			}
		}(data)
	}
	if context != nil && context.Err() != nil {
		return IConnectionSlideSetConnectionInstanceChangeOut{}, context.Err()
	}
	channel <- data
	var err error
	var v IConnectionSlideSetConnectionInstanceChangeOut
	if waitToComplete {
		v, err = data.Wait(func(interfaceName string, methodName string, err error) error {
			return err
		})
	} else {
		err = errors.NoWaitOperationError
	}
	if err != nil {
		return IConnectionSlideSetConnectionInstanceChangeOut{}, err
	}
	return v, nil
}

// Interface IConnectionSlide, Method: SetConnectionListChange
type IConnectionSlideSetConnectionListChangeIn struct {
	arg0 func([]IdAndName)
}

type IConnectionSlideSetConnectionListChangeOut struct {
}
type IConnectionSlideSetConnectionListChangeError struct {
	InterfaceName string
	MethodName    string
	Reason        string
}

func (self *IConnectionSlideSetConnectionListChangeError) Error() string {
	return fmt.Sprintf("error in data coming back from %v::%v. Reason: %v", self.InterfaceName, self.MethodName, self.Reason)
}

type IConnectionSlideSetConnectionListChange struct {
	inData         IConnectionSlideSetConnectionListChangeIn
	outDataChannel chan IConnectionSlideSetConnectionListChangeOut
}

func NewIConnectionSlideSetConnectionListChange(waitToComplete bool, arg0 func([]IdAndName)) *IConnectionSlideSetConnectionListChange {
	var outDataChannel chan IConnectionSlideSetConnectionListChangeOut
	if waitToComplete {
		outDataChannel = make(chan IConnectionSlideSetConnectionListChangeOut)
	} else {
		outDataChannel = nil
	}
	return &IConnectionSlideSetConnectionListChange{
		inData: IConnectionSlideSetConnectionListChangeIn{
			arg0: arg0,
		},
		outDataChannel: outDataChannel,
	}
}

func (self *IConnectionSlideSetConnectionListChange) Wait(onError func(interfaceName string, methodName string, err error) error) (IConnectionSlideSetConnectionListChangeOut, error) {
	data, ok := <-self.outDataChannel
	if !ok {
		generatedError := &IConnectionSlideSetConnectionListChangeError{
			InterfaceName: "IConnectionSlide",
			MethodName:    "SetConnectionListChange",
			Reason:        "Channel for IConnectionSlide::SetConnectionListChange returned false",
		}
		if onError != nil {
			err := onError("IConnectionSlide", "SetConnectionListChange", generatedError)
			return IConnectionSlideSetConnectionListChangeOut{}, err
		} else {
			return IConnectionSlideSetConnectionListChangeOut{}, generatedError
		}
	}
	return data, nil
}

func (self *IConnectionSlideSetConnectionListChange) Close() error {
	close(self.outDataChannel)
	return nil
}
func CallIConnectionSlideSetConnectionListChange(context context.Context, channel chan<- interface{}, waitToComplete bool, arg0 func([]IdAndName)) (IConnectionSlideSetConnectionListChangeOut, error) {
	if context != nil && context.Err() != nil {
		return IConnectionSlideSetConnectionListChangeOut{}, context.Err()
	}
	data := NewIConnectionSlideSetConnectionListChange(waitToComplete, arg0)
	if waitToComplete {
		defer func(data *IConnectionSlideSetConnectionListChange) {
			err := data.Close()
			if err != nil {
			}
		}(data)
	}
	if context != nil && context.Err() != nil {
		return IConnectionSlideSetConnectionListChangeOut{}, context.Err()
	}
	channel <- data
	var err error
	var v IConnectionSlideSetConnectionListChangeOut
	if waitToComplete {
		v, err = data.Wait(func(interfaceName string, methodName string, err error) error {
			return err
		})
	} else {
		err = errors.NoWaitOperationError
	}
	if err != nil {
		return IConnectionSlideSetConnectionListChangeOut{}, err
	}
	return v, nil
}

func ChannelEventsForIConnectionSlide(next IConnectionSlide, event interface{}) (bool, error) {
	switch v := event.(type) {
	case *IConnectionSlideDisconnectAllConnections:
		data := IConnectionSlideDisconnectAllConnectionsOut{}
		next.DisconnectAllConnections()
		if v.outDataChannel != nil {
			v.outDataChannel <- data
		}
		return true, nil
	case *IConnectionSlideDisconnectConnection:
		data := IConnectionSlideDisconnectConnectionOut{}
		next.DisconnectConnection(v.inData.arg0)
		if v.outDataChannel != nil {
			v.outDataChannel <- data
		}
		return true, nil
	case *IConnectionSlideResetAllConnectionParams:
		data := IConnectionSlideResetAllConnectionParamsOut{}
		next.ResetAllConnectionParams()
		if v.outDataChannel != nil {
			v.outDataChannel <- data
		}
		return true, nil
	case *IConnectionSlideResetConnectionParams:
		data := IConnectionSlideResetConnectionParamsOut{}
		next.ResetConnectionParams(v.inData.arg0)
		if v.outDataChannel != nil {
			v.outDataChannel <- data
		}
		return true, nil
	case *IConnectionSlideSend:
		data := IConnectionSlideSendOut{}
		data.Args0 = next.Send(v.inData.arg0)
		if v.outDataChannel != nil {
			v.outDataChannel <- data
		}
		return true, nil
	case *IConnectionSlideSetConnectionInstanceChange:
		data := IConnectionSlideSetConnectionInstanceChangeOut{}
		next.SetConnectionInstanceChange(v.inData.arg0)
		if v.outDataChannel != nil {
			v.outDataChannel <- data
		}
		return true, nil
	case *IConnectionSlideSetConnectionListChange:
		data := IConnectionSlideSetConnectionListChangeOut{}
		next.SetConnectionListChange(v.inData.arg0)
		if v.outDataChannel != nil {
			v.outDataChannel <- data
		}
		return true, nil
	default:
		return false, nil
	}
}
